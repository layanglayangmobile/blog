—
layout: post
title: Overview of Native Plugins in Unity 4
—

Ok, I know that we all love Unity. It is a great development tool for making games and 3d apps. It allows us to target multiple platforms also, from pc,osx,linux, browsers, consoles, and even mobiles. However, sometimes while Unity shines in making build once run anywhere platform, it still have to improve if developers want to build once run anywhere and use a specific platform feature. 

Unity gives developers a way for developers to access native platform specific features, that is by allowing native code to be called from directly from c# code. However, this doesn't mean that you can call API's or SDK function in native code directly; to call the native code is quite a hefty process and hard to control. Sometimes it better to use pattern like this :

unity c# - native code - native platform api

Using the pattern above means you don't call directly the platform API's, but you'll use like a proxy code in native that handles the logic and calling the API, bundle it in a function, then call the function from C#. This might be the roundabout way around, but it still faster than making calling to native code all from inside Unity.

Sadly, Unity documentation about plugins, making them, and explanation about Unity native tech is lacking. They only provide some basic explanation and examples.. Enough to get developers started, but for some high level native integration, it feels like you'll be in the dark and have to resort to trial-and-error measure to check what's happening and you'll definitely need to have about how the native platform work. 

This, however sparked an ecosystem where developers can sell plugins for native function, the developers package them in package promptly called unitypackage (usually just called Unity Plugins), and put them in an App Store-like store that you can access directly from the IDE, called Unity Asset Store.

You can check the plugin documentation here :

http://docs.unity3d.com/Documentation/Manual/Plugins.html

And you can check the Unity Asset Store here :

https://www.assetstore.unity3d.com/‎

So how exactly Unity call native code ? The ways are different for each platform. Here I will focus on Android and iOS (since those are platform that I have experience on).

## IOS

For iOS, basically what you have to do is declare the function that you want to call in the native code with the [DllImport("__Internal") ] annotation. This tells Unity that the function is in native code, and it just put a reference to it while the actual compilation will be on the Xcode project generated by Unity later. After you declare the function then you can call it just like you use C# code. Don't forget to using Runtime.InteropServices and you can run the code. Pretty simple.

Note : You have to absolutely make sure that the function that you reference is in a Objective-C class somewhere when you compile the Xcode project or else the it won't compile saying it not found the referenced function. You don't need to put the code in the Unity project, though Unity will bundle it up in an Xcode project, though sometimes you have to fix the symlinks, add frameworks, and add the headers files manually.

A lot of plugins automated this using PostProcessBuildPlayer, that is a shell script to run post processing your app has been build and can be customized to do various means, such as injecting your files to the Xcode project definition manually (It's annoying to do, trust me, I've been there). If you want to build your own plugins you have to take note also about Unity's iOS architecture of only having a single App Controller, and the need to use C code style and variable for the functions and sending variables back to Unity.

If that still not discourage you to try and build your own native iOS plugin for Unity, that's great. Now moving on to Android.

## ANDROID

Now for Android. It is actually much simple of including the native code to be bundled in the app since you just put it in in the plugins/android/ folder and it will be referenced and bundled automatically - this because Unity use Google's command line APK tool to build an Android project, so no more need to use an intermediary project (you can still generate an Eclipse project though - but with Android now moving to gradle build system, I haven't tested how it would play out -) 

Calling the function however, is a bit complex. As the documentation says, you can call it using JNI (Java Native Interface). It's very tedious and complicated to use this approach, and luckily Unity give us helper classes, in which we can use those class to warp JNI class, making it (a bit, just a little) simpler (and still tedious and complicated) process.
So with the helper class, the easiest example if you want to call a function in that is static (you don't have to create the object first), what you need to do is :

- make an AndroidJavaClass with the class name

- call the static function using AndroidJavaClass.callStatic()
Quite straight forward. Now what happens if you want to call a function that is not static ?

- make AndroidJavaClass

- make an AndroidJavaObject of the class with the constructor

- call the function using AndroidJavaObject.call()
Still straight forward, until you realized that calling the function from different classes all the time is not efficient, and thus you want to bundle it to a Java class in a JAR to handle all the native code. Now this is where it get quite complicated. Unity running in Android like its iOS counterpart has one main activity that running. To do something that related to activity however, you usually need to extend it and place your own custom activity then refer it as the main activity. It's pretty clear when you only have one custom activity as one plugin only, but if you have multiple plugins with multiple custom activity it will be very hard to impossible to make them work with each other since they basically like a famous plugin maker for Unity say, "Override the main Unity Activity in a non-friendly way".

## SUMMARY

If after reading all of this you still committed to try and build your own custom native plugins and calling your native code, congratulations ! It will be hard, but in the end it will bring you knowledge about how Unity handle things in the mobile side.. And you might can create some interesting combinations of native function and Unity code (some people even tried to run like Unity in a single window side by side with a native Android activity, and so on). Wish you your best in your endeavours ! :)
